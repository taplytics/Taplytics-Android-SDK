Creating experiments are easy using Taplytics. You can either use our visual editor or create code-based experiments. You can find documentation on how to do this below.

| Table of Contents |
| ----------------- |
| [Code Experiments](#code-experiments) |
| [Visual Editing](#visual-editing) |
| [First-view Experiments](#delay-load) |
| [List Running Experiments](#running-experiments) |

## Code Experiments

#### Setup

To set up a code-based experiment in Taplytics, please refer to the [Taplytics code-based experiment docs](https://taplytics.com/docs/guides/code-experiments).

#### Usage

Taplytics automatically generates the base needed for your code experiment. Paste it into the relevant section of your app, and apply the variables as necessary. 

It is suggested that you place the code calling the experiment in its own function (as opposed to an oncreate).

For example:

```java
@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(some_layout);
    
    // Run this code experiment. This triggers the experiment.
    runAnExperiment();
}
```
    
Then, in that function, add your experiment code generated by Taplytics, and modify it as you need.
    
```java
private void runAnExperiment(){
    Taplytics.runCodeExperiment("experiment name", new TaplyticsCodeExperimentListener() {
    
        @Override
        public void baselineVariation(Map<String, Object> variables) {
                
                        // Insert baseline variation code here.
                        Object myVar0 = variables.get("foo"); // can be null if no experiment is found
                    }
                    
        @Override
        public void experimentVariation(String variationName, Map<String, Object> variables) {
                    Object myVar0 = variables.get("foo"); // can be null if no experiment is found
                
                    if (variationName.equals("Variation 1")) {
                        // Insert Variation 1 variation code here.
                    } else if (variationName.equals("Variation 2")) {
                // Insert Variation 2 variation code here.
            }
        }
    
        @Override
        public void experimentUpdated() {
            // Use this method to re-run your code experiments when testing your experiment variations.
        }
    });
}
```

This separate function is suggested, because if you would like to update experiments instantly for debug testing or another reason, you can simply place the `runAnExperiment()` function into the `experimentUpdated()` block.

---

## Visual Editing

You don't have to do anything else!  You can use the Taplytics dashboard to make all your visual changes. See the docs on visual editing [here](https://taplytics.com/docs/guides/visual-experiments).

---

## Running Experiments

If you would like to see which variations and experiments are running on the device, there exists a `getRunningExperimentsAndVariations(TaplyticsRunningExperimentsListener listener)` function which provides a callback with a map of the current experiments and their running variation. An example:

```java
  Taplytics.getRunningExperimentsAndVariations(new TaplyticsRunningExperimentsListener() {
                    @Override
                    public void runningExperimentsAndVariation(Map<String, String> experimentsAndVariations) {
                        //TODO: Do something with the map.
                    }
                });
```

NOTE: This function runs asynchronously, as it waits for the updated properties to load from Taplytics' servers before returning the running experiments. 

---

## Delay Load

Taplytics has the option to delay the loading of your main activity while Taplytics gets initial view changes ready. Keep in mind that this initial load will only take a while the very first time, after that, these changes will be saved to disk and will not need a delay.

There are two methods to do this, **use both at the start of your oncreate after ```java setContentView()```**:

#### Delay Load With Image
In this instance, Taplytics takes care of the loading for you. Taplytics creates a splash screen with the provided image. The image will fade automatically after the given time, or when Taplytics has successfully loaded visual changes on the provided activity.

Method: ```Taplytics.delayLoad(Activity activity, Drawable image, int maxTime) ```

**Activity**: the activity (typically main activity) that will be covered in a splash image.

**Image**: A Drawable image that will be the splash screen.

**Max Time**:  Regardless of the results of Taplytics, the image will fade after this time. Milliseconds.

**Min Time**: Sometimes Taplytics loads things really fast, and this might make the image show only for a short amount of time. To keep this from happening, there is an optional minimum time option. Regardless of Taplytics loading experiments, the delayload wont finish until after this minumum time. 

**Examples**:

```java
        protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);

                Taplytics.delayLoad(this, getResources().getDrawable(R.drawable.image5), 2000);
                ...
```

**With a 1 second minimium time**

```java
                Taplytics.delayLoad(this, getResources().getDrawable(R.drawable.image5), 2000, 1000);
                ...
```

#### Delay Load with Callbacks
In this instance, Taplytics provides callbacks when the delay load should begin, and when the delay load ends. The callback will also return after the provided timeout time has been reached. This provides you the ability to show a splashscreen that is more than just a simple image. 

Method: ```Taplytics.delayLoad(int maxTime, TaplyticsDelayLoadListener listener) ```


**Max Time**: Regardless of the results of Taplytics, the image will fade after this time. Milliseconds.

**Min Time**: Sometimes Taplytics loads things really fast, and this might make the behavior of the callback undesirable. To keep this from happening, there is an optional minimum time option. Regardless of Taplytics loading experiments, the delayload wont finish until after this minumum time. 

**Listener**: This listener will provide the necessary callbacks.

**Examples**:

```java

        @Override
        protected void onCreate(Bundle savedInstanceState) {
                super.onCreate(savedInstanceState);
                setContentView(R.layout.main_layout);

                Taplytics.delayLoad(2000, new TaplyticsDelayLoadListener() {
                        @Override
                        public void startDelay() {
                                //Start delaying!
                        }

                        @Override
                        public void delayComplete() {
                                //Loading completed, or the given time has been reached. Insert your code here.
                        }
                });
                ...
                                              
```

**With a 1 second minimum time:**

```java
                Taplytics.delayLoad(2000,1000, ...

```

